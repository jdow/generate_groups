#!/usr/bin/python
import sys
import optparse
import ldap
import ldap.modlist as modlist
from generate_groups_config import LDAP_HOST, LDAP_USERNAME, LDAP_PASSWORD, LDAP_BASEDN, LDAP_GROUPS

# Return a list of attribute values currently in the target group in question
def get_group_attribute_values(conn, group_dn, group_attribute):
    data = {}
    try:
        data[group_attribute] = conn.search_s(
            group_dn,
            ldap.SCOPE_BASE,
            '(objectClass=*)',
            attrlist=['%s' % group_attribute]
        )[0][1]['%s' % group_attribute]
        # return a dict with format { attribute: ['value1', 'value2'] }
        return data[group_attribute]
    except (KeyError, IndexError):
        return []

# Get a list of all current SCM groups
# We just want all SCM groups current and future, so we short circuit
# reading SCM stuff form the config and just generate a config for it
def get_all_scm_groups(conn):
    try:
        scm_groups = conn.search_s(
            LDAP_BASEDN,
            ldap.SCOPE_SUBTREE,
            '(&(objectClass=posixGroup)(cn=scm*))',
            #attrlist=['cn']
        )
        return [group[0] for group in scm_groups]
    except (KeyError, IndexError):
        return []

# Since SCM groups store a mail attribute, we need to convert to their DN
def get_user_dn_by_mail(conn, email):
    try:
        user_obj = conn.search_s(
            LDAP_BASEDN,
            ldap.SCOPE_SUBTREE,
            '(mail=%s)' % email
        )
        return user_obj[0][0]
    except (IndexError, ldap.NO_SUCH_OBJECT):
        return False

# Find out which members should be in the group based on a filter
def get_all_potential_members_by_filter(conn, base, search_filter):
    data = {}
    try:
        all_members =  conn.search_s(
            base,
            ldap.SCOPE_SUBTREE,
            search_filter,
            attrlist=['dn']
        )
        data['member'] = [d[0] for d in all_members]
        return data
    except (KeyError, IndexError):
        return []

# Actually add a user to a Group
# This could blow up in any number of ways, so not trying to catch
# any exceptions here. Just let the script fail
def add_attribute_value_to_group(conn, attribute, value, group_dn):
    mod_list = [
        (ldap.MOD_ADD, attribute, value)
    ]
    conn.modify_s(group_dn, mod_list)

# Actually remove a user from a group
def remove_attribute_value_from_group(conn, attribute, value, group_dn):
    mod_list = [
        (ldap.MOD_DELETE, attribute, value)
    ]
    try:
        conn.modify_s(group_dn, mod_list)
    except ldap.OBJECT_CLASS_VIOLATION:
        # If we get to this point, a human must intervene, so notify about it and move on
        print 'Cannot remove last %s attribute %s from %s' % (attribute, value, group_dn)
        print 'Please remove %s from config and delete the group' % group_dn
        pass

# Create a new group, with sane defaults
# A groupOfNames must have at least one member. Since we don't know
# which members will be in a group, we initialize with the current
# bind user. This bind user will be removed by later logic.
# If we have an ipHostNumber, same thing, we need an initial sane value.
# Setting to localhost shouldn't hurt anything for the VPN, and it should get removed
# by later logic anyway.
def create_new_ldap_group(conn, group_dn, objectclasses, mail):
    group_cn = group_dn.split(',')[0].split('=')[1]
    attrs = {}
    if 'ipHost' in objectclasses:
        attrs['ipHostNumber'] = '127.0.0.1 # localhost'
    if 'mailObject' in objectclasses:
        attrs['mailObject'] = mail
    attrs['objectClass'] = objectclasses
    attrs['cn'] = group_cn
    attrs['description'] = 'Autogenerated by %s' % sys.argv[0]
    attrs['member'] = LDAP_USERNAME

    conn.add_s(group_dn, modlist.addModlist(attrs))

# We need this to return config set in a similar format to what
# the config file provides for regular groups. For each existing
# SCM group, we want three new groups. It's important that the new
# groups don't *start* with "scm_*", since we reserve that name space
# for actual SCM groups. We also want to convey the state of activity
# by adding all_, expired_, active_ prefixes to each group.
def scm_config(ldap_conn):
    # Generate groupOfNames groups from SCM groups
    all_scm_groups = get_all_scm_groups(ldap_conn)
    data_list = []
    for group_dn in all_scm_groups:
        group_cn = group_dn.split(',')[0].split('=')[1]
        for state in ['active', 'expired', 'all']:
            if state == 'active':
                search_filter = '(hgAccountEnabled=TRUE)'
            elif state == 'expired':
                search_filter = '(hgAccountEnabled=FALSE)'
            elif state == 'all':
                search_filter = '(objectClass=*)'
            data = {}
            data['name'] = 'cn=%s_%s,ou=groups,dc=mozilla' % (state, group_cn)
            data['scm_group'] = '%s' % group_dn
            data['search_filter'] = '%s' % search_filter
            data_list.append(data)
    return data_list

def main(prog_args = None):

    if prog_args is None:
        prog_args = sys.argv
    # command line options. For Cron usage, we probably want only --commit.
    # For debug purposes, --verbose is more helpful
    parser = optparse.OptionParser()
    parser.usage = "Script to generate LDAP groups from search filters"
    parser.add_option ('-v', '--verbose',
        action='store_true',
        default=False,
        dest = 'verbose',
        help='verbose output')
    parser.add_option ('--commit',
        action='store_true',
        default=False,
        dest='commit',
        help='run script in commit mode')

    options, args = parser.parse_args(sys.argv[1:])

    commit = options.commit
    verbose = options.verbose

    # Main LDAP connection. This is used by most functions later
    ldap_conn = ldap.initialize('ldap://%s' % LDAP_HOST)
    ldap_conn.start_tls_s()
    ldap_conn.simple_bind_s(LDAP_USERNAME, LDAP_PASSWORD)

    # Here we establish a distinct difference between groups that are
    # defined by the config file, and groups that result from our SCM
    # config function
    config_groups = LDAP_GROUPS
    scm_groups = scm_config(ldap_conn)
    all_groups = config_groups + scm_groups
    always_add = {}
    never_add = {}

    # This is the main loop. We go through all groups, both from config
    # file and from the SCM config function
    for ldap_group in all_groups:

        # This is all sanity checking, validation and error handling
        try:
            ldap_group['name']
        except KeyError:
            sys.exit("Configuration Error: no name provided!")
        else:
            group_dn = ldap_group['name']

        try:
            ldap_group['mail']
        except KeyError:
            if verbose:
                print 'No mail attribute for %s' % group_dn
            mail = []
        else:
            mail = ldap_group['mail']

        try:
            ldap_group['zimbraAlias']
        except KeyError:
            if verbose:
                print 'No zimbraAlias alias attribute for %s' % group_dn
            zimbraAlias = []
        else:
            zimbraAlias = ldap_group['zimbraAlias']

        try:
            ldap_group['search_filter']
        except KeyError:
            if verbose:
                print 'No search_filter for %s' % group_dn
            group_filter = ''
        else:
            group_filter = ldap_group['search_filter']

        if ldap_group in scm_groups:
            scm_group = ldap_group['scm_group']

        try:
            ldap_group['base']
        except KeyError:
            if verbose:
                print 'No Base DN provided for %s, assuming %s' % (group_dn, LDAP_BASEDN)
            group_basedn = LDAP_BASEDN
        else:
            group_basedn = ldap_group['base']

        try:
            ldap_group['always_add_exceptions']
        except KeyError:
            if verbose:
                print 'No always add exceptions for %s' % group_dn
            always_add['member'] = []
        else:
            if verbose:
                if ldap_group['always_add_exceptions'] == []:
                    print 'No always add exceptions for %s' % group_dn
                else:
                    print "Found always add exceptions for %s" % group_dn
            always_add['member'] = ldap_group['always_add_exceptions']

        try:
            ldap_group['never_add_exceptions']
        except KeyError:
            if verbose:
                print 'No never add exceptions for %s' % group_dn
            never_add['member'] = []
        else:
            if verbose:
                if ldap_group['never_add_exceptions'] == []:
                    print 'No never add exceptions for %s' % group_dn
                else:
                    print "Found never add exceptions for %s" % group_dn
            never_add = ldap_group['never_add_exceptions']

        try:
            ldap_group['nested_groups']
        except KeyError:
            if verbose:
                print 'No nested_groups for %s' % group_dn
            nested_groups = {}
        else:
            if verbose:
                if ldap_group['nested_groups'] == {}:
                    print 'No nested_groups for %s' % group_dn
                else:
                    print "Found nested_groups for %s" % group_dn
            nested_groups = ldap_group['nested_groups']

        # For each iteration of the main loop, we want to start with empty dicts and lists
        current_members = {}
        ldap_potential_members = {}
        ldap_nested_group_attributes = {}
        ldap_group_filter_attributes = {}
        ldap_scm_attributes = {}
        ldap_total_attributes = {}
        if mail or zimbraAlias:
            objectclasses = ['groupOfNames', 'top', 'mailObject']
        else:
            objectclasses = ['groupOfNames', 'top']

        # This loop is to ensure that we don't end up in an ambiguous situation
        # where someone adds the same user to both exceptions lists for a group
        for attribute in always_add:
            for exception in always_add[attribute]:
                if exception in never_add[attribute]:
                    print '%s found in both exceptions lists for group %s' % (exception, group_dn)
                    sys.exit("always_add_exceptions cannot be in never_add_exceptions!")

        # We calculate potential members slightly differently between config file groups and SCM groups
        if ldap_group in config_groups:
            if nested_groups:
                for group in nested_groups:
                    for attribute in group['attributes']:
                        if attribute == 'ipHostNumber':
                            if 'ipHost' not in objectclasses:
                                objectclasses.append('ipHost')
                        try:
                            ldap_nested_group_attributes[attribute]
                        except KeyError:
                            ldap_nested_group_attributes[attribute] = []
                        attribute_values = []
                        attribute_values = get_group_attribute_values(ldap_conn, group['group'], attribute)
                        ldap_nested_group_attributes[attribute].extend(attribute_values)
            if group_filter:
                ldap_group_filter_attributes = get_all_potential_members_by_filter(
                    ldap_conn,
                    group_basedn,
                    group_filter
                )
        elif ldap_group in scm_groups:
            ldap_scm_attributes['member'] = []
            members = get_group_attribute_values(ldap_conn, scm_group, 'memberUid')
            ldap_potential_members = get_all_potential_members_by_filter(
                ldap_conn,
                group_basedn,
                group_filter
            )
            # This next line is because LDAP is generally case insensitive
            # and because SCM groups reference only a mail attribute, it's
            # entirely possible for a user to exist in a group twice with
            # different case. this would cause an issue. So we convert
            # everything to lower case and then strip out duplicates
            members = [member.lower() for member in members]
            for member in set(members):
                member_dn = get_user_dn_by_mail(ldap_conn, member)
                if member_dn in ldap_potential_members['member']:
                    ldap_scm_attributes['member'].append(member_dn)
        else:
            sys.exit("There appears to be a logic error with %s" % ldap_group)

        # Before this point, we've calculated all the attributes that need to go
        # into our new group. Regardless of which way we gathered them, it's time
        # to gather them all up into one dict that will be used to modify the target group
        for dicts in (always_add, ldap_group_filter_attributes, ldap_nested_group_attributes, ldap_scm_attributes):
            for key in dicts:
                try:
                    ldap_total_attributes[key]
                except (KeyError):
                    ldap_total_attributes[key] = []
                ldap_total_attributes[key].extend(dicts[key])
        if mail:
            try:
                ldap_total_attributes['mail']
            except (KeyError):
                ldap_total_attributes['mail'] = []
            ldap_total_attributes['mail'].extend(mail)
        if zimbraAlias:
            try:
                ldap_total_attributes['zimbraAlias']
            except (KeyError):
                ldap_total_attributes['zimbraAlias'] = []
            ldap_total_attributes['zimbraAlias'].extend(zimbraAlias)
        # The rest here is the same for SCM and config file groups

        # Finally actually add users to the group
        for attribute in ldap_total_attributes:
            try:
                current_members[attribute] = get_group_attribute_values(
                    ldap_conn,
                    group_dn,
                    attribute
                )
            # From the above try block we can easily tell if a group
            # doesn't exist yet, so we'll use that exception to
            # trigger creation of a new group
            except ldap.NO_SUCH_OBJECT:
                # If it's a new group, there are no current attributes
                # We still need to set this list to empty, so that we don't fail later,
                # even if we end up not creating the group in the case of debug mode
                current_members[attribute] = []
                if not ldap_total_attributes['member']:
                    if verbose:
                        # Don't create an empty group
                        print 'No current or potential members for %s. Skipping' % group_dn
                else:
                    print '%s not found. Creating %s' % (group_dn, group_dn)
                    if commit:
                        create_new_ldap_group(ldap_conn, group_dn, objectclasses, mail)
                        current_members[attribute] = get_group_attribute_values(
                            ldap_conn,
                            group_dn,
                            attribute
                        )
            try:
                never_add_exception = never_add[attribute]
            except (KeyError):
                never_add_exception = []
            #remove duplicate entries from each list in the dict and set to lower case
            for attributes in current_members:
                current_members[attributes] = [lower_attribute.lower() for lower_attribute in current_members[attributes]]
                current_members[attributes] = list(set(current_members[attributes]))

            #remove duplicate entries from each list in the dict and set to lower case
            for attributes in ldap_total_attributes:
                ldap_total_attributes[attributes] = [lower_attribute.lower() for lower_attribute in ldap_total_attributes[attributes]]
                ldap_total_attributes[attributes] = list(set(ldap_total_attributes[attributes]))

            for value in ldap_total_attributes[attribute]:
                if value not in current_members[attribute] and value not in never_add_exception:
                    print 'adding %s value %s to group %s' % (attribute, value, group_dn)
                    if commit:
                        add_attribute_value_to_group(ldap_conn, attribute, value, group_dn)


            # And delete users that don't belong
            for value in current_members[attribute]:
                if value not in ldap_total_attributes[attribute] or value in never_add_exception:
                    print 'removing %s value %s from group %s' % (attribute, value, group_dn)
                    if commit:
                        remove_attribute_value_from_group(ldap_conn, attribute, value, group_dn)

if __name__ == '__main__':
    main()
